# 배열

# 배열

### 메모리 상에 원소를 연속하게 배치한 자료구조

## 배열의 성질

---

1. O(1)에 k번째 원소를 확인/ 변경 가능
2. 추가적으로 소모되는 메모리의 양(=overhead)가 거의 없음
3. Cache hit rate가 높음
4. 메모리 상에 연속한 구간을 잡아야 해서 할당에 제약이 걸림

## 구현

---

- Code
    
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    
    void insert(int idx, int num, int arr[], int& len)
    {
    	for(int i = len; i > idx; i--)
    	{
    		arr[i] = arr[i - 1];
    		arr[idx] = num;
    		len++;
    	}
    }
    
    void erase(int idx, int arr[], int& len)
    {
      for(int  = idx; i < len; i++)
    		arr[i] = arr[i + 1];
    }
    
    void printArr(int arr[], int& len){
      for(int i = 0; i < len; i++) cout << arr[i] << ' ';
      cout << "\n\n";
    }
    
    ```
    

## 사용 팁

---

전체를 특정 값으로 초기화 시 algorithm 헤더의 fill 함수 사용

- ex)
    
    ```cpp
    fill(first, first+3, 'x');
    fill_n(first, 2, 'y);
    ```
    

# STL vector

---

### vector는 배열과 달리 크기를 자유자재로 늘리거나 줄일 수 있음.

vector는 STL Container의 종류중 하나로, 클래스 템플릿의 형태로 구현되어 임의의 타입의 원소들을 위한 컨테이너를 만들 수 있으며, 한 컨테이너에는 한 가지 종류의 객체만 보관이 가능하다.

컨테이너 상에서 원소에 접근하는 방법은 크게 두가지가 있다.

1. 직접 함수 호출 접근
2. 반복자(iterator)를 이용해 접근

이 중 vector는 **순차 컨테이너(Sequence Contatiner)**의 한 종류이다.

쉽게, 가변길이 배열이라 생각하면 된다.

## 벡터의 시간 복잡도

---

- 임의의 위치 원소 접근 : O(1);
- 맨 뒤에 원소 추가 및 제거(push_back / pop_back) : amortized O(1); (평균적으로 O(1)이나, 최악의 경우 O(n))
- 임의의 위치 원소 추가 및 제거(insert, erase): O(n);

## 반복자(iterator)

---

컨테이너에서 원소에 접근할 수 있는 포인터와 같은 객체.

아래와 같은 형태로 정의되어있다.

- ex)
    
    ```cpp
    std::vector<int>::iterator itr = vec.begin();
    ```
    

현재 반복자가 가르키는 원소의 값을 보고 싶은 경우 아래와 같이 쓰며, 포인터로 *를 해서 주소값을 보는 것처럼 * 연산자를 이용해 itr이 가리키는 원소를 볼 수 있다. itr은 실제 포인터가 아니지만, * 연산자를 오버로딩해서 포인터처럼 동작하게 만든것이다.

- ex)
    
    ```cpp
    std::cout << *itr << std::endl;
    ```
    

## 예시 코드

---

- Code
    
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    
    int main()
    {
    	vector<int> v1(3,5);
    	cout << v1.size() << '\n';
    	v1.push_back(7);
    
    	vector<int> v2(2);
    	v2.insert(v2.begin()+1, 3);
    
    	vector<int> v3 = {1,2,3,4};
    	v3.erase(v3.begin()+2);
    
    	vecotr<int> v4;
    	v4 = v3;
    	cout = v4[0] MM v4[1] << v4[2] << '\n';
    	v4.pop_back();
    	v4.clear();
    }
    ```
    
- range-based for loop
    
    ```cpp
    vector<int> v1 = {1,2,3,4,5,6};
    
    for(int e : v1)
    	cout << e << ' ';
    
    for (int i = 0; i < v1.size(); i++)
    	cout < v1[i] << ' ';
    
    for (int i = 0; i <= v1.size() - 1; i++)
    	cout << v1[i] << ' ';
    ```
    
    int e : v1 → e에 v1의 원소들이 하나씩 들어가는 for문이 됨. 복사된 값이 e에 들어감
    
    int &e: v1 → 원본이 e에 들어감.
    

## 참고 사항

---

Vector Deep Copy : 인스턴스가 가진 메모리 자체가 복사되는 방식

Vector Shallow Copy : 참조 형식의 변수가 대입되는 방식

## 주의 사항

---

Vector의 size 메소드는 unsigned int를 반환.

따라서 빈 vector의 반복문 및 조건문 식 선언 등에서 V1.size - 1 과 같은 연산을 수행하게 시킬 시, 자동 형변환으로 인해 (unsigned int)0 - (int)1, 즉 4294967295와 같은 Overflow가 일어날 수 있다.